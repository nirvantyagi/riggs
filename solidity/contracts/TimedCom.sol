pragma solidity 0.8.11;


import "./RSA2048.sol";

library TimedCom {
  using RSA2048 for *; 

  struct Comm {
    RSA2048.Element h_hat;
    // need to add a pedersen commitment element
    // it would be a bytes32 elements
    bytes32 pc;
  }

  // public parameters

  // pp - fkps
  bytes constant g_rsa = "0x65237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534";
  bytes constant h_rsa = "0x65237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534";
  bytes constant N_bytes = "0x65237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534";
  
  // need PoE Keygen pk, vk
  bytes constant z_bytes = "0x65237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534652378416234871523847162534187326542165237841623487152384716253465237841623487152384716253418732654216523784162348715238471625346523784162348715238471625341873265421652378416234871523847162534";



  // pp - pedersen 
  bytes constant G_pc = "0x6523784162348715238471625341873265421652378416234871523847162534";
  bytes constant H_pc = "0x6523784162348715238471625341873265421652378416234871523847162535";




  function _new(bytes memory _rsa, bytes32 _pc) 
  internal pure returns (Comm memory comm) {
    comm.h_hat = RSA2048._new(_rsa);
    comm.pc = _pc;
  }

  function open(Comm memory comm, uint256 a, uint256 b, uint256 v) 
  internal view returns (bool) {
    RSA2048.Element memory z_rsa = RSA2048._new(z_bytes);
    RSA2048.Element memory N_rsa = RSA2048._new(N_bytes);
    RSA2048.Element memory z_pow_a = RSA2048.power(z_rsa, a, N_rsa);

    bool rsa_bool = comm.h_hat.cmp(z_pow_a);

    // obtain key via k = H(z, pp)
    bytes32 k = keccak256(z_pow_a.as_bytes());

    // need to add the pc stuff

    return rsa_bool;
  }

  // function as_bytes(Element memory a) 
  // internal pure returns (bytes memory) {
  //     return a.bn.val;
  // }


  // function mul(Element memory a, Element memory b, Element memory modulus) 
  // internal view returns (Element memory) {
  //     return Element((a.bn).modmul(b.bn, modulus.bn));
  // }

  // function power(Element memory base, uint e, Element memory modulus) 
  // internal view returns (Element memory) {
  //     Element memory e_elem = _new(abi.encodePacked(e));
  //     return Element((base.bn).prepare_modexp(e_elem.bn, modulus.bn));
  // }

  // function power(Element memory base, Element memory exponent, Element memory modulus) 
  // internal view returns (Element memory) {
  //     return Element((base.bn).prepare_modexp(exponent.bn, modulus.bn));
  // }


}